# ErrorBag

Все языки программирования отталкиваются от исключений в качестве сбора ошибок.  
Сильнейший плюс исключений в том, что исключение останавливает работу программы. В этом же сильнейший минус.

Бывает что вы хотите остановить не все логику программы, а только её часть.  
Если в логике выпадет исключение, она остановится целиком.  
Вы не сможете вернуться внутрь прерванной исключением функции, чтобы принять меры и продолжить её выполнение, она для вас потеряна.  
Это заставит вас дробить ваши функции на микроскопические до такой степени, что у вас будет больше функций, чем кода.

Современное сообщество считает исключения "правильным подходом к программированию".  
Исключения - это самозащита от того, что вы не доглядели и обработка совсем уж глупых случаяв неверного ввода или типа.  
А скажите, если вы отсылаете 10 записей, и 4 из них неверные, это исключение?  
С идеальной точки зрения - да. С реальной - нет, 60% уцелело.  
Мне жаль, но условия современности - это написание того, что можно быстро реализовать, не трогая старое, а не того, что архитектурно правильно с идеальной точки зрения.

Главная задача - это возможность собрать ошибки всего скрипта в единую кучу данных.

Вторая задача - экономить при этом память, то есть если вы вручную не вызовите _error_bag_start() ваши сборщики ошибок должны "ничего не делать"

Третья задача - возможность соединить часть ошибок из одной операции с частью ошибок из другой, то есть поиск по собранным ошибкам.  
Например, вы хотите отослать 10 телефонов, но из них каждый идет по 2 раза, то есть телефонов по сути 5. Вы отошлете 5 записей и ошибок будет 5.  
Но исходные данные предполагают, что их было 10. Вам нужно копировать ошибки по 2 раза.

Четвертая задача - когда вы используете исключения вы можете искать только по классу или интерфейсу ошибки.  
Как минимум - вы должны создать класс, привязать к нему интерфейс и потом по этому искать.  
Кроме того, что это долго, вы понятия не имеете как именно вы будете этот тип ошибок обрабатывать.  
Присвоение типа в этом случае почти не имеет смысла, поскольку он станет важен позже.  
Таким образом внедрены теги, которые позволяют на любом уровне при сборке пометить некие ошибки ключевым словом, чтобы дальше отталкиваться от него.

Пятая задача. Принять решение на месте. Старый добрый `if ($error) return null;`.  
Одна беда. Ошибки нижнего уровня не всегда ошибки для верхнего, но они никуда не исчезли для самого верхнего уровня.
Должна быть возможность превратить ошибки в предупреждения и проверить наличие ещё необработанных ошибок.

И шестая задача. Когда вы хотите выдать отчет в API JSON о том, что пошло в программе не так, а что прошло хорошо - вы хотите знать ГДЕ ошибка возникла.
Вот эта задача с которой исключения справляются на отлично - они собирают стек-трейс.  
Одна проблема. Сбор стек трейса занимает время.  
Вы теряете время на сбор ненужных трейсов, которые вы обработаете, а нужны они будут только если ошибка доберется до самого верха.

Представленный инструмент решает эти задачи.

Начните сбор ошибок (положив ящик в стек), в нужном месте - получите текущий ящик из стека, добавляйте в него ошибки, примите решение.  
В родительской функции переместите ошибки в предупреждения, присвоив им тег или путь, в котором они должны храниться.  
А собрав все - можете залпом вывести всё это в АПИ.

Обычно, когда я предлагаю идею в PHP сообщество, проходит 2 года и потом её внедряют как чью-то ещё. Сегодня 10.02.2024.

```php
<?php

require_once __DIR__ . '/error-bag.php';


function a()
{
    // > получаем текущий error-bag
    _error_bag($e);

    // > создаем дочерний error-bag, который будет отвечать за функцию aa()
    _error_bag_push($ee);
    
    $result = aa();
    
    // > завершаем дочерний error-bag (опционально - передаем его самого для проверки, не забыли ли глубже закрыть другие)
    _error_bag_pop($ee);

    // > соединяем закрытый в текущий с присвоением пути и тегов
    $e->merge($ee, 'aa', 'tag_aa');

    return $result;
}

function aa()
{
    _error_bag($e);

    $result = [];

    for ( $i = 0; $i <= 5; $i++ ) {
        _error_bag_push($ee);
        $_result = aaa();
        _error_bag_pop();

        // > соединяем закрытый в текущий как предупреждения (если ошибка была решена) с присвоением пути и тегов
        $e->warning($ee, [ 'aaa', $i ], 'tag_aaa');
        
        // > если во вложенном были ошибки - элемент пропускаем (принятие решение в родителе в зависимости от потомка)
        if ($ee->hasErrors()) {
            continue;
        }

        $result[] = $_result;
    }

    return $result;
}

function aaa()
{
    _error_bag($e);

    $result = [];

    for ( $i = 0; $i <= 5; $i++ ) {
        _error_bag_push($ee);
        $_result = aaaa($i);
        _error_bag_pop();

        $e->warning($ee, [ 'aaaa', $i ], 'tag_aaaa');
        if ($ee->hasErrors()) {
            continue;
        }

        $result[] = $_result;
    }

    return $result;
}

function aaaa($i)
{
    _error_bag($e);

    if ($i === 1) {
        // > добавляем ошибку, можно указать путь и теги
        $e->error("Error {$i}", $path = null, $tags = 'tag1'); // 1

    } elseif ($i % 2) {
        $e->error("Error {$i}", null, 'tag2'); // 2, 4

    } elseif ($i % 3) {
        // > добавляем предупреждение, можно указать путь и теги
        $e->warning("Warning {$i}", null, 'tag3'); // 3
    }
    
    // > принимаем решение в текущей функции, если нужно
    // if (! $e->hasErrors()) {
    // if (! $e->hasWarnings()) {
    if (! $e->isEmpty()) {
        return null;
    }

    return $i;
}


function main()
{
    // > включаем отлов ошибок, если эту функцию не вызвать - остальные будут возвращать null-обьекты
    _error_bag_start($e);


    $result = a();
    // var_dump($result); // > какой-то результат вашей логики


    // var_dump($e->toArray($implodeKeySeparator = '.')); // > все проблемы массивом
    // var_dump($e->getErrors()->toArray('.')); // > все ошибки массивом
    // var_dump($e->getWarnings()->toArray('.')); // > все предупреждения массивом

    // var_dump($e->toArrayNested($asObject = true)); // > все проблемы вложенным массивом


    // $ee = $e->getByTags($andTags = [ 'tag_aaa', 'tag1' ]);
    // var_dump($ee->toArray()); // 6 результатов

    // $ee = $e->getByTags($andTags = [ 'tag1', 'tag2' ]);
    // var_dump($ee->toArray()); // 0 результатов

    // $ee = $e->getByTags($tag = 'tag1', $orTag = 'tag2');
    // var_dump($ee->toArray()); // 18 результатов

    // $ee = $e->getByTags($tags = (object) [ 'tag_aaa', 'tag1' ], $orTags = (object) [ 'tag_aaa', 'tag2' ]);
    // var_dump($ee->toArray()); // 18 результатов


    // $ee = $e->getByPath($path = [ 'aaa', 1 ]);
    // var_dump($ee->toArray()); // 5 результатов

    // $ee = $e->getByPath($path = [ 'aaa', 1 ], $orPath = [ 'aaa', 2 ]);
    // var_dump($ee->toArray()); // 10 результатов

    // $ee = $e->getByPath($andPathes = (object) [ [ 'aaa', 1 ], [ 'aaaa', 1 ] ]);
    // var_dump($ee->toArray()); // 1 результат


    // $ee = $e->getByPath($path = [ 'aaa', 1 ]);
    // var_dump($ee->toArray()); // 4 результата

    // $ee = $e->getByPath($path = [ 'aaa', 1 ], $orPath = [ 'aaaa', 1 ]);
    // var_dump($ee->toArray()); // 1 результат

    // $ee = $e->getByPath($path = [ 'aaa', 1 ], $orPath = [ 'aaa', 2 ]);
    // var_dump($ee->toArray()); // 0 результатов    


    // > завершаем отлов ошибок, иначе следующая функция продолжит отлавливать в объявленный ранее error-bag
    _error_bag_end($e);
    // var_dump(ErrorBagStack::getInstance()); // empty stack
}


main();

```
