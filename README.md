# ErrorBag

Все языки программирования отталкиваются от исключений в качестве сбора ошибок.  
Сильнейший плюс исключений в том, что исключение останавливает работу программы. В этом же сильнейший минус.

Бывает что вы хотите остановить не все логику программы, а только её часть.  
Если в логике выпадет исключение, она остановится целиком.  
Вы не сможете вернуться внутрь прерванной исключением функции, чтобы принять меры и продолжить её выполнение, она для вас потеряна.  
Это заставит вас дробить ваши функции на микроскопические до такой степени, что у вас будет больше функций, чем кода.

Современное сообщество считает исключения "правильным подходом к программированию".  
Исключения - это самозащита от того, что вы не доглядели и обработка совсем уж глупых случаяв неверного ввода или типа.  
А скажите, если вы отсылаете 10 записей, и 4 из них неверные, это исключение?  
С идеальной точки зрения - да. С реальной - нет, 60% уцелело.  
Мне жаль, но условия современности - это написание того, что можно быстро реализовать, не трогая старое, а не того, что архитектурно правильно с идеальной точки зрения.

Главная задача - это возможность собрать ошибки всего скрипта в единую кучу данных.

Вторая задача - экономить при этом память, то есть если вы вручную не вызовите _error_bag_start() ваши сборщики ошибок должны "ничего не делать"

Третья задача - возможность соединить часть ошибок из одной операции с частью ошибок из другой, то есть поиск по собранным ошибкам.  
Например, вы хотите отослать 10 телефонов, но из них каждый идет по 2 раза, то есть телефонов по сути 5. Вы отошлете 5 записей и ошибок будет 5.  
Но исходные данные предполагают, что их было 10. Вам нужно копировать ошибки по 2 раза.

Четвертая задача - когда вы используете исключения вы можете искать только по классу или интерфейсу ошибки.  
Как минимум - вы должны создать класс, привязать к нему интерфейс и потом по этому искать.  
Кроме того, что это долго, вы понятия не имеете как именно вы будете этот тип ошибок обрабатывать.  
Присвоение типа в этом случае почти не имеет смысла, поскольку он станет важен позже.  
Таким образом внедрены теги, которые позволяют на любом уровне при сборке пометить некие ошибки ключевым словом, чтобы дальше отталкиваться от него.

Пятая задача. Принять решение на месте. Старый добрый `if ($error) return null;`.  
Одна беда. Ошибки нижнего уровня не всегда ошибки для верхнего, но все ещё предупреждения для самого верхнего уровня.
То есть должна быть возможность превратить ошибки в предупреждения и проверить наличие в ящике необработанных ошибок.

И шестая задача. Когда вы хотите выдать отчет в API JSON о том, что пошло в программе не так, а что прошло хорошо - вы хотите знать ГДЕ ошибка возникла.
Вот эта задача с которой исключения справляются на отлично - они собирают стек-трейс.  
Одна проблема. Сбор стек трейса занимает время. Вы теряете время на сбор ненужных трейсов, которые вы обработаете, а нужны они будут только если ошибка доберется до самого верха.
То есть нам нужно сохранение пути в месте обьединения двух групп ошибок.

Представленный инструмент решает эти задачи.

Начните сбор ошибок (положив ящик в стек), в нужном месте - получите текущий ящик из стека, добавляйте в него ошибки, примите решение.  
В родительской функции переместите ошибки в предупреждения, присвоив им тег или путь, в котором они должны храниться.  
А собрав все - можете залпом вывести всё это в АПИ.

Обычно, когда я предлагаю идею в PHP сообщество, проходит 2 года и потом её внедряют как чью-то ещё. Сегодня 10.02.2024.

```php
<?php

require_once __DIR__ . '/error-bag.php';


function a()
{
    _error_bag($e);

    _error_bag_push($ee);
    $result = aa();
    _error_bag_pop();

    _error_bag_merge($ee, 'aa', 'tag_aa');

    return $result;
}

function aa()
{
    _error_bag($e);

    $result = [];

    for ( $i = 0; $i <= 5; $i++ ) {
        _error_bag_push($ee);
        $_result = aaa();
        _error_bag_pop();

        _error_bag_warning($ee, [ 'aaa', $i ], 'tag_aaa');
        if ($ee->isErrors()) {
            continue;
        }

        $result[] = $_result;
    }

    return $result;
}

function aaa()
{
    _error_bag($e);

    $result = [];

    for ( $i = 0; $i <= 5; $i++ ) {
        _error_bag_push($ee);
        $_result = aaaa($i);
        _error_bag_pop();

        _error_bag_warning($ee, [ 'aaaa', $i ], 'tag_aaaa');
        if ($ee->isErrors()) {
            continue;
        }

        $result[] = $_result;
    }

    return $result;
}

function aaaa($i)
{
    if (! $i) {
        return $i; // 0

    }
    if ($i === 1) {
        _error_bag_error("Error {$i}", null, 'tag1'); // 1

    } elseif ($i % 2) {
        _error_bag_error("Error {$i}", null, 'tag2'); // 2, 4

    } elseif ($i % 3) {
        _error_bag_warning("Warning {$i}", null, 'tag3'); // 3
    }

    return null;
}


function main()
{
    // > включаем отлов ошибок, если эту функцию не вызвать - остальные будут возвращать null-обьекты
    _error_bag_start($e);


    $result = a();
    // var_dump($result); // > какой-то результат вашей логики


    // var_dump($e->toArray($implodeKeySeparator = '.')); // > все ошибки массивом
    // var_dump($e->toArrayNested($asObject = true)); // > все ошибки вложенным массивом


    // $ee = $e->getByTags($andTags = [ 'tag_aaa', 'tag1' ]);
    // var_dump($ee->toArray()); // 6 результатов

    // $ee = $e->getByTags($andTags = [ 'tag1', 'tag2' ]);
    // var_dump($ee->toArray()); // 0 результатов

    // $ee = $e->getByTags($tag = 'tag1', $orTag = 'tag2');
    // var_dump($ee->toArray()); // 18 результатов

    // $ee = $e->getByTags($tags = (object) [ 'tag_aaa', 'tag1' ], $orTags = (object) [ 'tag_aaa', 'tag2' ]);
    // var_dump($ee->toArray()); // 18 результатов


    // $ee = $e->getByPath($path = [ 'aaa', 1 ]);
    // var_dump($ee->toArray()); // 5 результатов

    // $ee = $e->getByPath($path = [ 'aaa', 1 ], $orPath = [ 'aaa', 2 ]);
    // var_dump($ee->toArray()); // 10 результатов

    // $ee = $e->getByPath($andPathes = (object) [ [ 'aaa', 1 ], [ 'aaaa', 1 ] ]);
    // var_dump($ee->toArray()); // 1 результат    


    // > завершаем отлов ошибок, иначе следующая функция продолжит отлавливать в объявленный выше error-bag
    _error_bag_end();

    var_dump(ErrorBagStack::getInstance()); // empty stack
}


main();
```
